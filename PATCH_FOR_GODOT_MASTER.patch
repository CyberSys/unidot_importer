diff --git a/editor/import/scene_importer_mesh.cpp b/editor/import/scene_importer_mesh.cpp
index 46eb4e4fdc..55b9d4a9a6 100644
--- a/editor/import/scene_importer_mesh.cpp
+++ b/editor/import/scene_importer_mesh.cpp
@@ -224,6 +224,7 @@ Ref<ArrayMesh> EditorSceneImporterMesh::get_mesh() {
 
 	if (mesh.is_null()) {
 		mesh.instance();
+		mesh->set_name(get_name());
 		for (int i = 0; i < blend_shapes.size(); i++) {
 			mesh->add_blend_shape(blend_shapes[i]);
 		}
diff --git a/editor/progress_dialog.cpp b/editor/progress_dialog.cpp
index 0b6a3798b3..edd2fde92b 100644
--- a/editor/progress_dialog.cpp
+++ b/editor/progress_dialog.cpp
@@ -207,7 +207,7 @@ bool ProgressDialog::task_step(const String &p_task, const String &p_state, int
 		DisplayServer::get_singleton()->process_events();
 	}
 
-	Main::iteration(); // this will not work on a lot of platforms, so it's only meant for the editor
+	////////Main::iteration(); // this will not work on a lot of platforms, so it's only meant for the editor
 	return cancelled;
 }
 
diff --git a/modules/gdscript/gdscript_vm.cpp b/modules/gdscript/gdscript_vm.cpp
index 2216fcab2d..da623d96ed 100644
--- a/modules/gdscript/gdscript_vm.cpp
+++ b/modules/gdscript/gdscript_vm.cpp
@@ -2324,23 +2324,30 @@ Variant GDScriptFunction::call(GDScriptInstance *p_instance, const Variant **p_a
 
 				GET_INSTRUCTION_ARG(counter, 0);
 				GET_INSTRUCTION_ARG(container, 1);
-
-				Array *array = VariantInternal::get_array(container);
-
-				VariantInternal::initialize(counter, Variant::INT);
-				*VariantInternal::get_int(counter) = 0;
-
-				if (!array->is_empty()) {
-					GET_INSTRUCTION_ARG(iterator, 2);
-					*iterator = array->get(0);
-
-					// Skip regular iterate.
-					ip += 5;
-				} else {
-					// Jump to end of loop.
+				
+				if (container->get_type() != Variant::ARRAY) {
+					ERR_PRINT("Attempted to iterate over non-array!");
+					ERR_PRINT(this->get_name());
 					int jumpto = _code_ptr[ip + 4];
 					GD_ERR_BREAK(jumpto < 0 || jumpto > _code_size);
 					ip = jumpto;
+				} else {
+					Array *array = VariantInternal::get_array(container);
+
+					VariantInternal::initialize(counter, Variant::INT);
+					*VariantInternal::get_int(counter) = 0;
+					if (!array->is_empty()) {
+						GET_INSTRUCTION_ARG(iterator, 2);
+						*iterator = array->get(0);
+
+						// Skip regular iterate.
+						ip += 5;
+					} else {
+						// Jump to end of loop.
+						int jumpto = _code_ptr[ip + 4];
+						GD_ERR_BREAK(jumpto < 0 || jumpto > _code_size);
+						ip = jumpto;
+					}
 				}
 			}
 			DISPATCH_OPCODE;
diff --git a/modules/gltf/gltf_document.cpp b/modules/gltf/gltf_document.cpp
index caf8e3f48f..bc2d029621 100644
--- a/modules/gltf/gltf_document.cpp
+++ b/modules/gltf/gltf_document.cpp
@@ -2449,6 +2449,9 @@ Error GLTFDocument::_parse_meshes(Ref<GLTFState> state) {
 		const Dictionary &extras = d.has("extras") ? (Dictionary)d["extras"] : Dictionary();
 		Ref<EditorSceneImporterMesh> import_mesh;
 		import_mesh.instance();
+		if (d.has("name")) {
+			import_mesh->set_name(d["name"]);
+		}
 		for (int j = 0; j < primitives.size(); j++) {
 			Dictionary p = primitives[j];
 
@@ -2998,6 +3001,12 @@ Error GLTFDocument::_parse_images(Ref<GLTFState> state, const String &p_base_pat
 			// We can land here if we got an URI with base64-encoded data with application/* MIME type,
 			// and the optional mimeType property was not defined to tell us how to handle this data (or was invalid).
 			// So let's try PNG first, then JPEG.
+
+			// Go through all loaders and try each one:
+
+			//Ref<Texture2D> image_texture = ResourceLoader::load(path);
+
+
 			ERR_FAIL_COND_V(Image::_png_mem_loader_func == nullptr, ERR_UNAVAILABLE);
 			img = Image::_png_mem_loader_func(data_ptr, data_size);
 			if (img.is_null()) {
@@ -3006,12 +3015,13 @@ Error GLTFDocument::_parse_images(Ref<GLTFState> state, const String &p_base_pat
 			}
 		}
 
-		ERR_FAIL_COND_V_MSG(img.is_null(), ERR_FILE_CORRUPT,
-				vformat("glTF: Couldn't load image index '%d' with its given mimetype: %s.", i, mimetype));
-
 		Ref<ImageTexture> t;
 		t.instance();
-		t->create_from_image(img);
+		if (img.is_null()) {
+			ERR_PRINT(vformat("glTF: Couldn't load image index '%d' with its given mimetype: %s.", i, mimetype));
+		} else {
+			t->create_from_image(img);
+		}
 
 		state->images.push_back(t);
 	}
diff --git a/scene/main/node.cpp b/scene/main/node.cpp
index 933f67db68..a926d4f436 100644
--- a/scene/main/node.cpp
+++ b/scene/main/node.cpp
@@ -1247,6 +1247,12 @@ void Node::add_child(Node *p_child, bool p_legible_unique_name) {
 	/* Validate name */
 	_validate_child_name(p_child, p_legible_unique_name);
 
+	Node *parent = data.parent;
+	while (parent) {
+		ERR_FAIL_COND_MSG(parent == this, "Can't add child '" + p_child->get_name() + "' which is also ancestor of parent '" + get_name() + "'");
+		parent = parent->data.parent;
+	}
+
 	_add_child_nocheck(p_child, p_child->data.name);
 }
 
@@ -2748,6 +2754,8 @@ void Node::_bind_methods() {
 
 	ClassDB::bind_method(D_METHOD("set_scene_instance_load_placeholder", "load_placeholder"), &Node::set_scene_instance_load_placeholder);
 	ClassDB::bind_method(D_METHOD("get_scene_instance_load_placeholder"), &Node::get_scene_instance_load_placeholder);
+	ClassDB::bind_method(D_METHOD("set_editable_instance", "node", "is_editable"), &Node::set_editable_instance);
+	ClassDB::bind_method(D_METHOD("is_editable_instance", "node"), &Node::is_editable_instance);
 
 	ClassDB::bind_method(D_METHOD("get_viewport"), &Node::get_viewport);
 
diff --git a/servers/rendering_server.cpp b/servers/rendering_server.cpp
index 809343114c..0830fe9678 100644
--- a/servers/rendering_server.cpp
+++ b/servers/rendering_server.cpp
@@ -521,7 +521,7 @@ Error RenderingServer::_surface_set_data(Array p_arrays, uint32_t p_format, uint
 						ERR_FAIL_COND_V(p_arrays[ai].get_type() != Variant::PACKED_FLOAT32_ARRAY, ERR_INVALID_PARAMETER);
 
 						Vector<float> array = p_arrays[ai];
-						int32_t s = ARRAY_CUSTOM_R_FLOAT - ai + 1;
+						int32_t s = type - ARRAY_CUSTOM_R_FLOAT + 1;
 
 						ERR_FAIL_COND_V(array.size() != p_vertex_array_len * s, ERR_INVALID_PARAMETER);
 
